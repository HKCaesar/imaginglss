<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>imaginglss.utils.sharedmem.pool &mdash; ImagingLSS 0.9 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="ImagingLSS 0.9 documentation" href="../../../../index.html" />
    <link rel="up" title="imaginglss.utils.sharedmem" href="../sharedmem.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">ImagingLSS 0.9 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../../../imaginglss.html" >imaginglss</a> &raquo;</li>
          <li class="nav-item nav-item-3"><a href="../sharedmem.html" accesskey="U">imaginglss.utils.sharedmem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for imaginglss.utils.sharedmem.pool</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">mapreduce</span> <span class="kn">import</span> <span class="n">MapReduce</span>
<span class="kn">import</span> <span class="nn">backends</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Pool&#39;</span><span class="p">,</span> <span class="s">&#39;TPool&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="Pool"><a class="viewcode-back" href="../../../../imaginglss.utils.sharedmem.pool.html#imaginglss.utils.sharedmem.pool.Pool">[docs]</a><span class="k">class</span> <span class="nc">Pool</span><span class="p">(</span><span class="n">MapReduce</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">MapReduce</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backends</span><span class="o">.</span><span class="n">ProcessBackend</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TPool"><a class="viewcode-back" href="../../../../imaginglss.utils.sharedmem.pool.html#imaginglss.utils.sharedmem.pool.TPool">[docs]</a><span class="k">class</span> <span class="nc">TPool</span><span class="p">(</span><span class="n">MapReduce</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">MapReduce</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backends</span><span class="o">.</span><span class="n">ThreadBackend</span><span class="p">)</span>
</div>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">import numpy</span>
<span class="sd">from multiprocessing.sharedctypes import RawValue</span>
<span class="sd">import multiprocessing as mp</span>
<span class="sd">import threading</span>
<span class="sd">import signal</span>
<span class="sd">import Queue as queue</span>
<span class="sd">from warnings import warn</span>
<span class="sd">import traceback</span>
<span class="sd">import heapq</span>

<span class="sd">import backends</span>

<span class="sd">if False:</span>
<span class="sd"> class Pool:</span>
<span class="sd">  &quot;&quot;&quot;</span>
<span class="sd">    with Pool() as p</span>
<span class="sd">      def work(a, b, c):</span>
<span class="sd">        pass</span>
<span class="sd">      p.starmap(work, zip(A, B, C))</span>

<span class="sd">    To use a Thread pool, pass use_threads=True</span>
<span class="sd">    there is a Lock accessible as &#39;with p.lock&#39;</span>

<span class="sd">    Refer to the module document.</span>
<span class="sd">  &quot;&quot;&quot;</span>
<span class="sd">  def __enter__(self):</span>
<span class="sd">    return self</span>
<span class="sd">  def __exit__(self, type, value, traceback):</span>
<span class="sd">    pass</span>

<span class="sd">  @property</span>
<span class="sd">  def iter(self):</span>
<span class="sd">    return self._tls.iter</span>
<span class="sd">  @property</span>
<span class="sd">  def rank(self):</span>
<span class="sd">    return self._tls.rank</span>

<span class="sd">  @property </span>
<span class="sd">  def local(self):</span>
<span class="sd">    return self._tls.local</span>

<span class="sd">  def __init__(self, np=None, use_threads=False):</span>
<span class="sd">    if np is None: np = backends.cpu_count()</span>
<span class="sd">    self.np = np</span>
<span class="sd">    self.serial = self.np == 0</span>

<span class="sd">    if use_threads:</span>
<span class="sd">        if threading.currentThread().name != &#39;MainThread&#39;:</span>
<span class="sd">            self.serial = True</span>
<span class="sd">            warn(&#39;nested TPool is avoided&#39;, stacklevel=2)</span>
<span class="sd">        self.backend = backends.ThreadBackend</span>
<span class="sd">    else:</span>
<span class="sd">        self.backend = backends.ProcessBackend</span>

<span class="sd">    backend = self.backend</span>

<span class="sd">    self._tls = backend.StorageFactory()</span>
<span class="sd">    self._tls.rank = None</span>
<span class="sd">    self._tls.local = {}</span>

<span class="sd">    self.critical = backend.LockFactory()</span>
<span class="sd">    self.stop = backend.EventFactory()</span>
<span class="sd">    self.stop.clear()</span>
<span class="sd">    self.ordered = ordered(self)</span>

<span class="sd">  def starmap(self, work, sequence, reduce=None):</span>
<span class="sd">    return self.map(work, sequence, reduce=reduce, star=True)</span>

<span class="sd">  def map(self, workfunc, sequence, reduce=None, star=False):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">      calls workfunc on every item in sequence. </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    if backends.get_debug() or self.serial: </span>
<span class="sd">      return self.map_debug(workfunc, sequence, reduce, star)</span>

<span class="sd">    if hasattr(sequence, &quot;__getitem__&quot;):</span>
<span class="sd">        indirect = True</span>
<span class="sd">    else:</span>
<span class="sd">        indirect = False</span>

<span class="sd">    def slave(S, Q, rank):</span>
<span class="sd">      self._tls.rank = rank</span>
<span class="sd">      while True:</span>
<span class="sd">        if self.stop.is_set():</span>
<span class="sd">           return</span>
<span class="sd">        try:</span>
<span class="sd">           workcapsule = S.get(timeout=1)</span>
<span class="sd">        except queue.Empty:</span>
<span class="sd">           continue</span>
<span class="sd">        if workcapsule is None: </span>
<span class="sd">          Q.put((None, None))</span>
<span class="sd">          #S.task_done()</span>
<span class="sd">          #print &#39;worker&#39;, rank, &#39;exit&#39;</span>
<span class="sd">          break</span>

<span class="sd">        i, work = workcapsule</span>
<span class="sd">        self._tls.iter = i</span>
<span class="sd">       # print &#39;worker&#39;, rank, &#39;doing&#39;, i</span>
<span class="sd">        try:</span>
<span class="sd">          if indirect:</span>
<span class="sd">            work = sequence[i]</span>
<span class="sd">          if star: out = workfunc(*work)</span>
<span class="sd">          else: out = workfunc(work)</span>
<span class="sd">          Q.put((i, out))</span>
<span class="sd">          #S.task_done()</span>
<span class="sd">        except Exception as e:</span>
<span class="sd">          Q.put((e, traceback.format_exc()))</span>
<span class="sd">          #S.task_done()</span>
<span class="sd">        #print &#39;worker&#39;, rank, &#39;done&#39;, i</span>

<span class="sd">    P = []</span>
<span class="sd">    Q = self.backend.QueueFactory(self.np)</span>
<span class="sd">    S = self.backend.QueueFactory(1)#self.np)</span>

<span class="sd">#   the result is not sorted yet</span>
<span class="sd">    R = []</span>
<span class="sd">    error = []</span>

<span class="sd">    def feeder(S):</span>
<span class="sd">        for i, work in enumerate(sequence):</span>
<span class="sd">          # we do not send work through pipe</span>
<span class="sd">          # because work may be large array and pickling them is</span>
<span class="sd">          # painful</span>
<span class="sd">          while True:</span>
<span class="sd">            try:</span>
<span class="sd">              if len(error) &gt; 0: </span>
<span class="sd">                  # if error detected</span>
<span class="sd">                  # just stops feeding at all.</span>
<span class="sd">                  # we will die with an exception</span>
<span class="sd">                  self.stop.set()</span>
<span class="sd">                  return</span>
<span class="sd">              if indirect:</span>
<span class="sd">                  S.put((i, None), timeout=1)</span>
<span class="sd">              else:</span>
<span class="sd">                  S.put((i, work), timeout=1)</span>
<span class="sd">              break</span>
<span class="sd">            except queue.Full:</span>
<span class="sd">              continue</span>
<span class="sd">        for rank in range(self.np):</span>
<span class="sd">            S.put(None) # sentinel</span>

<span class="sd">    def fetcher(Q):</span>
<span class="sd">        L = self.np</span>
<span class="sd">        while L &gt; 0:</span>
<span class="sd">          # see if the total number of alive processes</span>
<span class="sd">          # match the number of processes that hasn&#39;t</span>
<span class="sd">          # finished gracefully</span>
<span class="sd">          # if unmatch and </span>
<span class="sd">          # the queue is still empty,(no worker finished </span>
<span class="sd">          # in the meanwhile)</span>
<span class="sd">          # some workers have been killed by OS</span>
<span class="sd">          if numpy.sum([p.is_alive() for p in P]) &lt; L \</span>
<span class="sd">               and Q.empty():</span>
<span class="sd">            ind = Exception(&quot;Some processes killed unexpectedly\n&quot;)</span>
<span class="sd">            r = &quot;Unknown Traceback&quot;</span>
<span class="sd">          else:</span>
<span class="sd">            try:</span>
<span class="sd">              ind, r = Q.get(timeout=2)</span>
<span class="sd">            except queue.Empty:</span>
<span class="sd">              continue</span>
<span class="sd">          if ind is None:</span>
<span class="sd">            # the worker dead, nothing done</span>
<span class="sd">            #print &#39;gracefully worker finished&#39;, L</span>
<span class="sd">            L = L - 1</span>
<span class="sd">          elif isinstance(ind, Exception): </span>
<span class="sd">            #print &#39;worker errored&#39;, L</span>
<span class="sd">            L = L - 1</span>
<span class="sd">            error.append((ind, r))</span>
<span class="sd">            # after first error is received, report and stop</span>
<span class="sd">            # monitoring the queue</span>
<span class="sd">            break</span>
<span class="sd">          else:</span>
<span class="sd">            # success</span>
<span class="sd">            try:</span>
<span class="sd">              if reduce is not None:</span>
<span class="sd">                if isinstance(r, tuple):</span>
<span class="sd">                  r = reduce(*r)</span>
<span class="sd">                else:</span>
<span class="sd">                  r = reduce(r)</span>
<span class="sd">              R.append((ind, r))</span>
<span class="sd">            except Exception as e:</span>
<span class="sd">              error.append((e, traceback.format_exc()))</span>
<span class="sd">              break</span>
<span class="sd">        #print &#39;fetcher ended&#39;, L</span>


<span class="sd">    # the slaves will not raise KeyboardInterrupt Exceptions</span>
<span class="sd">    old = signal.signal(signal.SIGINT, signal.SIG_IGN)</span>

<span class="sd">    for rank in range(self.np):</span>
<span class="sd">        p = self.backend.SlaveFactory(target=slave, args=(S, Q, rank))</span>
<span class="sd">        P.append(p)</span>

<span class="sd">    for p in P:</span>
<span class="sd">        p.start()</span>

<span class="sd">    fetcher = threading.Thread(target=fetcher, args=(Q,))</span>
<span class="sd">    fetcher.start()</span>
<span class="sd">    feeder = threading.Thread(target=feeder, args=(S,))</span>
<span class="sd">    feeder.start()</span>

<span class="sd">    signal.signal(signal.SIGINT, old)</span>

<span class="sd">    while feeder.is_alive():</span>
<span class="sd">        try:</span>
<span class="sd">            feeder.join(timeout=2)</span>
<span class="sd">        except (KeyboardInterrupt, SystemExit) as e:</span>
<span class="sd">            error.append((e, traceback.format_exc()))</span>
<span class="sd">            #print error</span>

<span class="sd">    #print &#39;feeder joined&#39;</span>
<span class="sd">    while fetcher.is_alive():</span>
<span class="sd">    #    print &#39;fetcher joining&#39;</span>
<span class="sd">        fetcher.join(timeout=2)</span>

<span class="sd">    # now report any errors</span>
<span class="sd">    if len(error) &gt; 0:</span>
<span class="sd">        raise Exception(str(error[0][0]) + &quot;\ntraceback:\n&quot; + error[0][1])</span>
<span class="sd">    else:</span>
<span class="sd">      # must clear Q before joining the Slaves or we deadlock.</span>
<span class="sd">      while not Q.empty():</span>
<span class="sd">        raise Exception(&quot;unexpected extra queue item: %s&quot; % str(Q.get()))</span>

<span class="sd">      for rank, p in enumerate(P):</span>
<span class="sd">        p.join()</span>

<span class="sd">    heapq.heapify(R)</span>
<span class="sd">    return [ heapq.heappop(R)[1] for i in range(len(R))]</span>

<span class="sd">  def map_debug(self, work, sequence, reduce=None, star=False):</span>
<span class="sd">    def realreduce(x):</span>
<span class="sd">      if reduce is None: return x</span>
<span class="sd">      if isinstance(x, tuple):</span>
<span class="sd">        return reduce(*x)</span>
<span class="sd">      else:</span>
<span class="sd">        return reduce(x)</span>
<span class="sd">    if star: return [realreduce(work(*x)) for x in sequence]</span>
<span class="sd">    else: return [realreduce(work(x)) for x in sequence]</span>

<span class="sd"> class TPool(Pool):</span>
<span class="sd">    def __init__(self, np=None):</span>
<span class="sd">        Pool.__init__(self, use_threads=True, np=np)</span>


<span class="sd"> class ordered(object):</span>
<span class="sd">    def __init__(self, pool):</span>
<span class="sd">        self.pool = pool</span>
<span class="sd">        self.event = pool.backend.EventFactory()</span>
<span class="sd">        self.count = RawValue(&#39;l&#39;)</span>
<span class="sd">        self.count.value = 0</span>
<span class="sd">        self.event.set()</span>
<span class="sd">    def __enter__(self):</span>
<span class="sd">        while True:</span>
<span class="sd">            self.event.wait()</span>
<span class="sd">            if self.count.value == self.pool.iter:</span>
<span class="sd">                self.event.clear()</span>
<span class="sd">                return self</span>
<span class="sd">    def __exit__(self, type, value, traceback):</span>
<span class="sd">        self.count.value = self.count.value + 1</span>
<span class="sd">        self.event.set()</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">ImagingLSS 0.9 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../../../imaginglss.html" >imaginglss</a> &raquo;</li>
          <li class="nav-item nav-item-3"><a href="../sharedmem.html" >imaginglss.utils.sharedmem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Yu Feng, Martin White.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>